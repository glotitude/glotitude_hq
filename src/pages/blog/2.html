[template]
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Glotitude HQ. Ctchi. День второй</title>

    <link href="/static/css/main.css" type="text/css" rel="stylesheet">
</head>
<body>

<div class="title"><h3>Glotitude HQ</h3></div>

[import "header.html"/]

<div class="content">
    <h4 class="article_title">Ctchi. День второй</h4>

    <p>
        Я ведь не говорил что решил назвать веб-фреймворк Ctchi? Я даже не знаю почему я выбрал такое название. Наверное
        хотел что-то броское :) Поэтому первый вариант был catchy. Но это банально, поэтому он стал catchi (chi - это
        как энергия ци). А потом я убрал 'a', чтобы название вообще никто не понял. Видимо в этом и смысл: чтобы
        никто не понял.
    </p>

    <p>
        В общем сегодня был второй день того как я пытаюсь написать свой фреймворк. Он начался с того что я убрал все
        panic! из кода. Заменил все unwrap, на аналоги с _or_else. Добавил оставшиеся HTTP методы и сделал отдельный
        на случай, если я что-то пропустил: UNKNOWN, - буду потом бросать 405 Method Not Allowed (или сразу 400 Bad
        Request) при валидации. Починил парсинг заголовков (не в том плане что теперь я получаю их все, я всё ещё
        разбираю только первый ^_^", а в том, что иногда они почему-то не приходили). И после этого приступил к главному
        блюду.
    </p>

    <p>
        Многопоточный веб-сервер. Эта часть тоже была описана в книге, поэтому я решил быстренько её добить и перейти к
        реализации контроллеров. Если бы я знал. Первый кусок кода выглядел очень просто.
    </p>

    <p>
        <code>
            <pre>
                fn main() {
                    let listener = TcpListener::bind(&#x22;127.0.0.1:7878&#x22;).unwrap();

                    for stream in listener.incoming() {
                        let stream = stream.unwrap();

                        thread::spawn(|| {
                            handle_connection(stream);
                        });
                    }
                }
            </pre>
        </code>
    </p>

    <p>
        Проблема в том, что я уже нагородил своего дизайна вокруг. И теперь я пытался запустить тред из метода класса,
        в результате чего у меня утекала ссылка на объект.
    </p>

    <p>
        <code>
            <pre>
                pub fn start(&#x26;self) -&#x3E; std::io::Result&#x3C;()&#x3E; {
                    let listener = TcpListener::bind(self.config.bind_path)?;

                    for stream in listener.incoming() {
                        let stream = stream.unwrap();

                        thread::spawn(|| {
                            self.handle_client(stream);
                        })
                    }
                    Ok(())
                }
            </pre>
        </code>
    </p>

    <p>
        Ну вы поняли, в этот момент Rust показал все свои замечательные фичи: время жизни, владение объектом, копирование
        и клонирование. И я то в целом понимал почему он не хочет отдавать ссылку в отдельный тред (нет гарантии, что
        основной тред не умрёт по пути), но это ни разу не помогало решить проблему.
    </p>

    <p>
        Первым делом я вынес обработку
        запроса в отдельную структуру RequestHandler. Теперь я мог гарантировать, что у каждого треда она своя. Проблема
        оказалась с конфигом, который всё ещё должен был передаваться в обработчик запроса. Я пробовал менять время жизни, в
        результате совсем запутался, но как оказалось убрал кучу лишнего кода. Пробовал реализовывать Copy и Clone,
        компилятор даже не удосужился поменять ошибку. Попробовал использовать Arc. Безнадёжно. В этот момент мне
        посказали: а ты пробовал сделать так, как рассказываешь своим студентам? Изолировать маленький кусок кода и
        эксперементировать с ним. оО. Нет, я так не делал. Пара проб, и я понял что не так с Arc: я передаю его в
        треды в цикле, в результате он после первой же итерации оказывается мувнутым (value moved into closure here,
        in previous iteration of loop). Вызываем clone() и всё работает. Ееееей. Всего лишь спустя 5 часов я убедил
        Rust, что я достоин работающей программы.
    </p>

    <p>
        <code>
            <pre>
                pub fn start(self) -&#x3E; std::io::Result&#x3C;()&#x3E; {
                    let listener = TcpListener::bind(self.config.bind_path)?;
                    let config = Arc::new(self.config);

                    for stream in listener.incoming() {
                        let stream = stream.unwrap();
                        let c = config.clone();

                        thread::spawn(|| {
                            let handler = RequestHandler {};

                            handler.handle_request(stream, c);
                        });
                    }
                    Ok(())
                }
            </pre>
        </code>
    </p>

    <p>
        После этого, меня ничего не останавливало дочитать главу до конца: сделать свой тред пул и переписать на него
        веб-сервер. Многие вещи, которые я нашёл за этот день, на самом деле рассказывались в учебнике :) Возможно
        стоило сначала прочитать его. Но, ничто не учит лучше чем свои ошибки.
    </p>

    <p>
        Последнее что я сделал, это установил на сервер супервизор, чтобы он поднимал приложение, когда оно упало.
        Завтра надо будет разобраться, почему не проходят запросы от домена и сделать путь для статики (прописывать
        стили для каждой страницы ужасно утомительно).
    </p>

    <p class="signature">
        by Glotitude 2020.05.10
    </p>

</div>

<div class="footer">
    Glotitude © 2020
</div>
</body>
</html>
[endtemplate]
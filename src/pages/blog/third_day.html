<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Glotitude HQ. Ctchi. День третий</title>

    <link href="/static/css/main.css" type="text/css" rel="stylesheet">
</head>
<body>

<div class="title"><h3>Glotitude HQ</h3></div>

<div class="header">
    <a href="/">Home</a>
    <a href="/blog">Блог</a>
</div>

<div class="content">
    <h4 class="article_title">Ctchi. День третий</h4>

    <p>
        Третий день начался с того, что я сделал для статики отдельный префикс и правило загрузки, теперь я мог вынести
        все стили в css файл и перестать копировать их между страницами.
    </p>

    <p>
        <code>
            <pre>
                let content_file_path = if request.url.starts_with(config.static_uri_pref) {
                    format!("{}{}", config.base_path, request.url)
                } else {
                    format!("{}{}", config.base_path, config.routes.get_route(request.url.as_ref()))
                };

                let content = fs::read_to_string(content_file_path)
                    .unwrap_or_else(|error| { error.to_string() });
            </pre>
        </code>
    </p>

    <p>
        Мне не очень нравилось что за это отвечает request_handler, а не сами Routes, но без большого рефакторинга у
        меня получалась циклическая зависимость между Routes и Config. А большой рефакторинг в этот момент времени я
        затевать не хотел: уже было понятно что я слишком сильно связал обработку запроса с остальным приложением и
        это придётся менять (скорее всего вынести в middleware).
    </p>

    <p>
        Следующим пунктом было сделать свои контроллеры, чтобы прописывать логику открытия страницы в них. Да, у меня
        ещё нет работы с базой, да и системы шаблонов для страницы тоже нет, но кого это волнует :) я представлял как
        могу это сделать через функции (похоже на раннии версии Django), но так же хотел рассмотреть вариант с типажами (
        trait) и аттрибутами. Работу первых я ещё как-то представлял, но не знал особенностей Rust, про вторые не слышал
        ничего.
    </p>

    <p>
        Практически сразу стало понятно что типажи мне не помогут. Определять их в рантайме я не могу. Делать по методу
        для каждого типа запроса кажется не красивым решением. Да и в целом, реализация типажа добавляет намного больше
        кода, чем хотелось бы использовать для роутинга. Зато аттрибуты привели меня к attribute-like macros, где как
        раз был пример про роутинг запросов в веб приложении. Книга снова пришла мне на помощь ^_^.
    </p>

    <p>
        Потратив оставшийся день в попытках разобраться как работают макросы я так и не сделал удобную систему роутов,
        чтож и такое бывает. Я попробовал посмотреть на код веб фреймворка rocket, но так как ребята ушли далеко
        вперёд меня, то понять как работают их макросы было очень тяжело. В какой-то момент я всё же сумел сделать
        маломальский процедурный макрос в отдельном проекте песочнице, но мне всё ещё далеко до полноценной реализации.
    </p>



    <p class="signature">
        by Glotitude 2020.05.11
    </p>

</div>

<div class="footer">
    Glotitude © 2020
</div>
</body>
</html>
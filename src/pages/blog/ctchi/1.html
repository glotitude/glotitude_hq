[template]
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Glotitude HQ. Ctchi. День первый</title>

    <link href="/static/css/main.css" type="text/css" rel="stylesheet">
</head>
<body>

<div class="title"><h3>Glotitude HQ</h3></div>

[import "header.html"/]

<div class="content">
    <h4 class="article_title">Ctchi. День первый</h4>

    <p>
        Идея поднять свой блог зарождалась в голове давно. Но просто развернуть на сервере django и начать писать статьи
        казалось странной затеей. В конечном итоге, разве не могу я использовать для ведения блога специальный сервис,
        зачем делать именно свой сайт? Потому что могу? Звучит скучно.
    </p>

    <p>
        Мысль о том, что я могу сделать веб-сервер и фреймворк сам, пришли неожиданно. Я как раз думал о том, чтобы
        сделать очередной подход к изучению языка Rust (это была бы уже 4-я попытка). А учить язык по книжке или на
        синтетических проектах меня не привлекала. Делать проект, которым я не буду пользовать тоже не хотелось
        (существует огромное количество приложений, которые можно написать, но скорее всего в мире или будут аналоги
        лучше, или не хватит времени на полноценную разработку, плюс у меня в фирме Rust запрещён, поэтому применить
        результаты было бы невозможно). Но ведь можно соединить создание своего блога и создание всех необходимых
        механизмов для него, да ещё и написать об этом цикл статей. Не долго думая я приступил к работе.
    </p>

    <p>
        Все знают шутку про Vim. У него только два режима работы: пикать и всё портить. Rust чем-то похож на Vim, ты
        пишешь код, компилятор орёт на тебя, ты переписываешь код... он всё ещё орёт на тебя. Изучение Rust долгое
        и болезненное, в процессе полностью уничтожается чувство собственного достоинства программиста (а может
        я просто недостаточно сообразителен).
    </p>

    <p>
        Наученный прошлым горьким опытом общения с ржавым, я решил плюнуть на красивый дизайн и начать с MVP.
    </p>

    <p>
    <ol>
        <li>Мне нужно уметь получать запрос от браузера</li>
        <li>Понимать его содержимое</li>
        <li>Отдавать отбратно обычную статическую html страницу</li>
    </ol>
    </p>

    <p>
        Всё. Этого достаточно для того чтобы сделать обычный home page. Мне не требуется делать механизм маршрутизации.
        Поддерживать разные методы HTTP запросов. Не нужен nginx или другой веб-сервер. Даже база данных не нужна.
        Я начал искать как в Rust можно взаимодействовать с сокетами. И сразу нашёл
        <a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">std::net::TcpListener</a>.
        Скажу честно, документация у языка потрясающая. Я давно говорил что лучшая документация, которую я видел у django.
        Так вот, теперь я могу сказать что у Rust она лучше. Описание структуры, примеры использования чуть ли не для
        каждого метода. Просто скопировав код с сайта и немного подтюнив его я смог прочитать запрос от браузера.
        Отлично, первый шаг готов.
    </p>

    <p>
        <code>
            <pre>
            [code]
            pub fn start(&#x26;self) -&#x3E; std::io::Result&#x3C;()&#x3E; {
                let listener = TcpListener::bind(self.config.bind_path)?;

                // accept connections and process them serially
                for stream in listener.incoming() {
                    self.handle_client(stream?);
                }
                Ok(())
            }
            [endcode]
            </pre>
        </code>
    </p>

    <p>
        Со вторым пунктом не так просто. Чтобы понимать содержимое HTTP запроса, надо понимать как он устроен, и
        понимать не в общем: метод, URI, заголовки, тело, - а как я могу его распарсить. Ушёл в гугл. Гугл отправил
        меня обратно в документацию языка. Вау, оказывается тут есть книжка, и
        <a href="https://doc.rust-lang.org/book/ch20-01-single-threaded.html">последняя глава</a> как раз о том как написать
        свой веб-сервер. Ок. Начало звучит знакомо. Ага, это я уже сделал. И это тоже. А вот и описание того как можно
        разобрать HTTP запрос. Следующие несколько часов я провёл в попытках написать красивый код разбора запроса.
        Казалось бы, что тут сложного: разбил строку по разделителю, потом каждый из блоков ещё по разделителю, получил
        нужные элементы массива и всё. Но нет, тут он возвращает итератор, тут у меня получается ссылка на ссылку.
        В какой-то момент я даже начал писать второй метод, где я разбирал запрос побайтово, просто чтобы не слышать
        очередной потом ругани от заботливого компилятора. Потом одёрнул себя, почитал документацию по всему что принимало
        участие в этом коде и написал как надо (желание разбирать байты запроса всё ещё живо и когда-нибудь я сделаю
        бенчмарк и перепишу код, но не сейчас).
    </p>

    <p>
        <code>
            <pre>
            [code]
            enum HttpMethod {
                GET,
                POST,
                PUT,
                DELETE
            }

            struct Request {
                method: HttpMethod,
                url: String,
                headers: String,
                body: String,
            }

            fn parse_request(&#x26;self, request: &#x26;[u8]) -&#x3E; Request {
                let request_str = String::from_utf8_lossy(request);
                let blocks = request_str.split(&#x22;\r\n&#x22;).collect::&#x3C;Vec&#x3C;&#x26;str&#x3E;&#x3E;();
                let method = blocks[0].split(&#x22; &#x22;).collect::&#x3C;Vec&#x3C;&#x26;str&#x3E;&#x3E;();
                let http_method = match method[0] {
                    &#x22;GET&#x22; =&#x3E; HttpMethod::GET,
                    &#x22;POST&#x22; =&#x3E; HttpMethod::POST,
                    &#x22;PUT&#x22; =&#x3E; HttpMethod::PUT,
                    &#x22;DELETE&#x22; =&#x3E; HttpMethod::DELETE,
                    _ =&#x3E; panic!(&#x22;Dont know method {}&#x22;, method[0]),
                };
            
                Request {
                    method: http_method,
                    url: method[1].to_string(),
                    headers: blocks[1].to_string(),
                    body: String::new(),
                }
            }
            [endcode]
            </pre>
        </code>
    </p>

    <p>
        Я даже сделал enum для HTTP методов, сейчас они не принимают никакого участия в логике сервера, зато успешно его
        кладут в случае неизвестного метода. Ещё мы пишем только первый заголовок, это тоже требуется починить.
    </p>

    <p>
        Оставался третий пункт: ответ браузеру. Этот код я взял из книги, параллельно научившись читать из файла. Боже,
        что-то появляется на экране.
    </p>

    <p>
        Я был почти доволен результатом. Я мог поднять сервер, положить рядом index.html и опубликовать свой сайт. Что я
        хотел - это иметь больше чем одну страницу. Мне нужны были роуты. Ещё одна структура данных и пара методов к ней.
        Внутри обычная HashMap (+1 коллекция к моему знанию Rust). Url я уже умел получать из запроса, он и выступал
        ключом.
    </p>

    <p>
        Я почитал как опубликовать библиотеку, собрал её, отправил в crate.io, успешно создал второй проект (сам сайт),
        подключил к нему зависимость, прописал роуты, наполнил содежимым страницы и теперь вы это читаете.
    </p>

    <p>
        Конечно не всё шло хорошо. И я сделал для себя несколько выводов по результатам запуска: нельзя вместо обработки
        ошибок использовать panic!, в MVP будет огромное количество непродуманных ситуаций, которые будут просто
        складывать сервер. Логгирование. Без него практически невозможно понять что сломалось, в результате всё равно
        раскидаешь принты по коду, чтобы отладиться.
    </p>

    <p>
        Что дальше. Всё остальное :) можно сказать что ничего ещё и не сделано. Нужна обработка ошибок, нужны логи,
        нужна хорошая система роутов, надо спроектировать сам фреймворк, добавить в него контроллеры, слой DAO, сделать
        веб-сервер многопоточным, нужна база данных (и у меня уже даже есть идеи какой она должна быть). Это лишь первый
        день из многих.
    </p>

    <p class="signature">
        by Glotitude 2020.05.09
    </p>

</div>

[import "footer.html"/]
</body>
</html>
[endtemplate]
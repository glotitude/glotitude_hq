[template]
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Glotitude HQ. Ctchi. День седьмой (исправление шестого дня)</title>

    <link href="/static/css/main.css" type="text/css" rel="stylesheet">
</head>
<body>

<div class="title"><h3>Glotitude HQ</h3></div>

[import "header.html"/]

<div class="content">
    <h4 class="article_title">Ctchi. День седьмой (исправление шестого дня)</h4>

    <p>
        Казалось бы, добавил длинну ответа, проверил локально, всё работает, статья открывается, ты счастлив. Но нет,
        выкатил на прод и половина статей падает с теми же симптомами что были раньше. И это всё большие статьи, т.е.
        где-то длина контента считается не верно :( Теперь стоит задача разобраться где.
    </p>

    <p>
        Так как локально ошибка не воспроизводилась от слова совсем, то я решил временно положить сайт и начать
        выкладывать в прод тестовую версию (всё равно никто не читает :)). Попробовал добавлять константу в Content-Length,
        но браузер всё равно вычитывал сильно меньше чем я просил. Пробовал добавить заголовки Content-Type, Connection,
        Content-Encoding, всё бестолку, поведение не менялось от слова совсем. Гугление в сторону "почему браузер рвёт
        соединение" ни к чему не приводило, поэтому я решил погуглить подобную проблему для TcpStream.
    </p>

    <p>
        Пол часа и я вышел на вопрос
        <a href="https://users.rust-lang.org/t/cant-write-to-tcpstream-without-reading-from-it/16713">про чтение из стрима</a>,
        который казалось не имел никакого отношения ко мне, если бы не фраза: <i>The code is problematic because it relies
        on OS buffering on the client or server side. Without buffering, a peer can only send if the other peer is
        reading and vice versa. With buffering, the same problem exists but only if the buffers are full.</i> А что, если
        моя джоба завершается раньше чем система успевает ответить браузеру (честно, я не имею ни малейшего представления
        что я пишу, потому что для меня это выглядит как абсурд, я сделал write, потом flush, откуда взялась проблема оО).
        В общем, я влепил в конце хендлера двухсекундный слип. И он заработал. Страница открылась. Со всем контентом.
    </p>

    <p>
        А после этого я ещё внимательнее перечитал ссылку и понял что проблема у меня один в один. Читаю я 512 байт, а
        приходит больше 600. Поднял размер буфера, убрал слип и всё заработало. И Content-Length тоже больше не требовался.
        Что подтверждает цитаты из RFC на SoF: у ответа нет ни одного обязательного заголовка. Абсолютно не понятно
        почему изначально добавление заголовка помогло.
    </p>

    <p>
        Так как просто увеличивать буффер бессмысленно - всегда найдётся запрос, которые привысит его размер. То надо
        было начать читать запрос до тех пор пока он не закончится. И тут случился очередной поток проблем: read -
        блокирующий вызов, т.е. если тебе ничего не прислали, то он не вернёт Ok(0), он будет сидеть и ждать;
        read_to_end - ждёт EOF, очевидно что браузер никакие EOF не присылает; выставление неблокирующего режима у
        TcpStream начало кидать мне ошибку. В результате поисков в интернете я нашёл пример с использованием BufReader,
        который у меня заработал.
    </p>

    <p>
        <code>
            <pre>
                let mut request_input = Vec::new();
                let mut reader = BufReader::new(stream);

                for line in reader.by_ref().lines() {
                    let l = line.unwrap();
                    request_input.extend_from_slice(l.as_bytes());
                    if l == String::from("") {
                        break;
                    }
                };
            </pre>
        </code>
    </p>

    <p>
        Этот вариант работает, но всё равно мне не нравится: кажется что я аллоцирую сильно больше памяти на строки, чем
        мог бы, но пока код останется таким.
    </p>

    <p class="signature">
        by Glotitude 2020.05.17
    </p>

</div>

[import "footer.html"/]
</body>
</html>
[endtemplate]
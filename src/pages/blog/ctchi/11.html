[template]
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Glotitude HQ. Ctchi. День одинадцатый (шаблонизатор)</title>

    <link href="/static/css/main.css" type="text/css" rel="stylesheet">
</head>
<body>

<div class="title"><h3>Glotitude HQ</h3></div>

[import "header.html"/]

<div class="content">
    <h4 class="article_title">Ctchi. День одинадцатый (шаблонизатор)</h4>

    <p>
        Получив удобные роуты я решил переключиться на другую насущную проблему: шаблоны. Добавлять HTTP методы сейчас
        нет смысла, у меня везде GET запросы; типизировать параметры роутов тоже можно позже, это больше похоже на вишенку
        на торте. А вот уметь включать один шаблон в другой, параметризировать их, иметь внутри циклы и условия - это
        полезная штука.
    </p>

    <p>
        Прежде чем придумывать красивый синтаксис для шаблонизатора, надо было понять как он может работать. Очевидно,
        что я могу инклудить шаблоны и передавать параметры буквально через регулярки. Быстро, дёшево, сердито. Но вот с
        управляющими конструкциями такая штука уже не сработает. Как только у них появится вложенность, регулярка вернёт
        мне некоректный кусок шаблона. Т.е. нужно что-то сложнее: парсить dom дерево, хранить его у себя, иметь узлы тегов,
        текста и элементов шаблонизатора. И в момент сборки дерева в строку, обрабатывать все необходимые конструкции.
        Всё ещё было не очевидно как я буду работать с циклами, смогу ли я сделать их типизированными и т.д. Но это
        проблема на будущее (всегда есть запасной вариант: сделать всё строкой :) ). Час кодинга и появился такой
        незамысловатый и откровенное некрасивый код:
    </p>

    <p>
        <code>
            <pre>
                pub fn parse(&#x26;mut self, html: &#x26;str) -&#x3E; Tag {
                    let html_bytes = html.as_bytes();
                    let mut children = Vec::new();
                    let mut name_bytes = Vec::new();
                    let mut i = 1;

                    // read name
                    while html_bytes&#x5B;i&#x5D; != b&#x27;&#x3E;&#x27; {
                        name_bytes.push(html_bytes&#x5B;i&#x5D;);
                        i += 1;
                    }

                    let mut name = String::from_utf8(name_bytes).unwrap();
                    i += 1;

                    // read children
                    while html_bytes&#x5B;i+1&#x5D; != b&#x27;/&#x27; {
                        let child = self.parse(&#x26;html&#x5B;i..html.len()&#x5D;);
                        i += child.size;

                        children.push(child);
                    }

                    // read tag closing
                    while html_bytes&#x5B;i&#x5D; != b&#x27;&#x3E;&#x27; {
                        i += 1;
                    }

                    Tag {
                        name,
                        attributes: Vec::new(),
                        children,
                        size: i + 1
                    }
                }
            </pre>
        </code>
    </p>

    <p>
        Что здесь плохо. Он не умеет обрабатывать незакрытые теги (типа meta), он не умеет парсить параметры тегов, он
        неочевидно работает с индексом (понять почему я инкементирую его тут и там сходу не получится), он хранит длину
        тега, хотя это очевидно информация, которая не обязательна для его использования. Из хорошего: он работает со
        срезами строк и ссылками, не делая никакого копирования.
    </p>

    <p>
        Самая большая проблема - это конечно парсинг текста. Вторая проблема - это незакрытые теги, падать на таких
        страницах было бы странно, учитывая, что браузер сумеет её отрисовать (да html - это боль, как и большая часть
        веба).
    </p>

    <p>
        Чтобы парсить текст, мне нужно было хранить другую структуру данных. Т.е. список детей у тега становился
        гетерогенным. Хм... Кажется для этого использовали энумы. А к ним ещё и отлично заходит pattern matching.
    </p>

    <p>
        <code>
            <pre>
                pub enum HtmlNode {
                    TAG(Tag),
                    TEXT(Text),
                }

                // внутри функции парсинга выбираем, что мы будем парсить
                let child = if html_bytes&#x5B;i&#x5D; == b'<' {
                    self.parse_tag(&html&#x5B;i..html.len()&#x5D;)
                } else {
                    self.parse_text(&html#&#x5B;i..html.len()&#x5D;)
                };

                // размер теперь тоже придётся получать по другому. child передаём по ссылке, чтобы не происходил move
                let size = match &child {
                    HtmlNode::TAG(e) => e.size,
                    HtmlNode::TEXT(e) => e.value.len(),
                };
            </pre>
        </code>
    </p>

    <p>
        Я был доволен кодом. И решил поделиться им с Илюхой. Он поспрашивал как что работает. А потом заметил, что для
        шаблонизатора мне в принципе не нужно парсить html (я и сам об этом задумывался, но почему-то решил, что иметь
        на руках дерево тегов будет удобнее). Подумав ещё раз я понял что он прав. Значит ли это, что мой код бесполезен?
        Конечно нет. Фактически я его и поменяю, только теперь text - это весь html, а tag - это мои теги шаблонизатора.
        Но я всё равно доволен сегодняшним днём. Я сумел написать обычный код на Rust, достаточно эффективный, который
        решает мою "выдуманную" проблему.
    </p>

    <p class="signature">
        by Glotitude 2020.05.25
    </p>

</div>

<div class="footer">
    Glotitude © 2020
</div>
</body>
</html>
[endtemplate]